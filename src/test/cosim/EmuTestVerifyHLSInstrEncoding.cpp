// Copyright (c) 2019 Xilinx
//
// BSD v3 License
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.
//
// * Neither the name of BISMO nor the names of its
//   contributors may be used to endorse or promote products derived from
//   this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include <iostream>
#include <vector>
#include <cassert>
#include <string.h>
#include "platform.h"
#include "EmuTestVerifyHLSInstrEncoding.hpp"
#include "BISMOInstruction.hpp"

using namespace std;

WrapperRegDriver * p;
EmuTestVerifyHLSInstrEncoding * t;

// read a single instruction from the queue as generated by the
// instruction generator
BISMOInstruction readInstr() {
  std::vector<unsigned int> rinds = t->getStatusRegs()["out_bits"];
  while(t->get_out_valid() != 1);
  BISMOInstruction ins_read;
  //ins_read((3-r)*32 + 31, (3-r)*32) = p->readReg(rinds[r]);
  for(int r = 0; r < 4; r++) {
    ins_read(32*(r+1)-1, 32*r) = p->readReg(rinds[r]);
  }
  t->set_out_ready(0);
  t->set_out_ready(1);
  return ins_read;
}

int main(int argc, char const *argv[]) {
  bool t_okay = true;
  try {
    cout << "EmuTestVerifyHLSInstrEncoding running" << endl;
    p = initPlatform();
    t = new EmuTestVerifyHLSInstrEncoding(p);
    // test instruction encoding for HLS:
    // create golden (expected) instruction stream
    std::vector<BISMOInstruction> golden;
    BISMOSyncInstruction sync;
    BISMOExecRunInstruction exec;
    sync.isRunCfg = 0;
    sync.targetStage = 1;
    sync.isSendToken = 1;
    sync.chanID = 2;
    golden.push_back(sync.asRaw());
    for(unsigned int i = 0; i < 10; i++) {
      exec.isRunCfg = 1;
      exec.targetStage = 1;
      exec.lhsOffset = i;
      exec.rhsOffset = 10 - i;
      exec.numTiles = 2 * i;
      exec.shiftAmount = i & 2;
      golden.push_back(exec.asRaw());
    }
    sync.isRunCfg = 0;
    sync.targetStage = 1;
    sync.isSendToken = 0;
    sync.chanID = 2;
    golden.push_back(sync.asRaw());
    // compare generated vs golden instructions
    for(auto & i : golden) {
      BISMOInstruction read_ins = readInstr();
      bool ok = (read_ins == i);
      t_okay &= ok;
      cout << "Equal? " << ok << endl;
      if(!ok) {
        cout << "Expected: " << i << endl;
        cout << "Found: " << read_ins << endl;
      }
    }
    delete t;
    deinitPlatform(p);
  } catch(const char * e) {
    cout << "Exception: " << e << endl;
  }
  cout << "Test passed: " << (t_okay ? "yes" : "no") << endl;

  return t_okay ? 0 : -1;
}
